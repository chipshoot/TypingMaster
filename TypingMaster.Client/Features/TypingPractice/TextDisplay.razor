<style>
    .w-full {
    width: 100%;
    }

    .h-full {
    height: 100%;
    }

    .space-y-2> :not([hidden])~ :not([hidden]) {
    --tw-space-y-reverse: 0;
    margin-top: calc(.5rem * calc(1 - var(--tw-space-y-reverse)));
    margin-bottom: calc(.5rem * var(--tw-space-y-reverse))
    }

    .justify-between {
    justify-content: space-between;
    }

    .items-center {
    align-items: center;
    }

    .bg-transparent {
    background-color: transparent;
    }

    .resize-none {
    resize: none;
    }

    .outline-none {
    outline: 2px solid transparent;
    outline-offset: 2px
    }

    .top-0 {
    top: 0;
    }

    .left-0 {
    left: 0;
    }

    .p-4 {
    padding: 1rem;
    }

    .point-events-none {
    pointer-events: none;
    }

    .absolute {
    position: absolute;
    }

    .relative {
    position: relative;
    }

    .monospace-font {
    font-family: 'JetBrains Mono', 'Fira Code', 'Source Code Pro', 'Consolas', 'DejaVu Sans Mono', 'Roboto Mono', 'Monaco', 'Courier New', monospace;
    font-size: 1.1rem;
    letter-spacing: 0.05em;
    line-height: 1.5;
    font-feature-settings: "calt" 1, "ss01" 1, "ss02" 1;
    /* Enable font features for better readability */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    }

    /* Ensure consistent character width for input area */
    #typingInput {
    font-family: inherit;
    /* Inherit the monospace font from parent */
    font-size: inherit;
    letter-spacing: inherit;
    line-height: inherit;
    }

    .sample-line {
        color: #333;
        line-height: 1.6;
        padding: 5px 0;
        border-radius: 4px 4px 0 0;
    }

    .input-line {
        color: #333;
        line-height: 1.6;
        padding: 5px 0;
        position: relative;
        min-height: 30px;
        background-color: #fff;
        border-radius: 0 0 4px 4px;
        margin-bottom: 10px;
    }

    .arrowUp {
    display: inline-block;
    width: 0;
    height: 0;
    border-left: 0.5ch solid transparent;
    border-right: 0.5ch solid transparent;
    border-bottom: 1ch solid black;
    margin-left: calc(var(--arrow-position, 0) * 1ch);
    }

    .arrow.hidden {
    visibility: hidden;
    }
</style>
<div class="pointer-events-none sample-line">
    @{

        if (_isActive)
        {
            if (!string.IsNullOrEmpty(InputChars))
            {
                var cursorPosition = InputChars.Length - 1;
                var charClass = GetCharClass(cursorPosition);
                if (cursorPosition < Text.Length)
                {
                    var curChar = Text[cursorPosition].ToString();
                    if (curChar != " ")
                    {
                        _textSpans[InputChars.Length - 1] = new MarkupString($"<span key='{cursorPosition}' class='monospace-font {charClass}'>{curChar}</span>");
                    }
                }
            }
        }
        foreach (var span in _textSpans)
        {
            @span
        }
    }
</div>
<div tabindex="0" class="pointer-events-none input-line mt-2">
    @if (_isActive)
    {
        _typedSpans = new MarkupString[InputChars.Length];
        for (var i = 0; i < InputChars.Length; i++)
        {
            var charClass = GetCharClass(i);
            var displayChar = InputChars[i] == ' ' ? "&nbsp;" : InputChars[i].ToString();
            _typedSpans[i] = new MarkupString($"<span key='{i}' class='monospace-font {charClass}'>{displayChar}</span>");
        }
    } 

    @foreach (var span in _typedSpans)
    {
        @span
    }

    @if (_isActive && !IsLineCompleted)
    {
        <span key="@InputChars.Length" class="monospace-font arrowUp"></span>
    }
</div>

@code {

    [Parameter]
    public int Id { get; set; }

    [Parameter]
    public int CurrentLineId
    {
        set => _isActive = value == Id;
    }

    [Parameter]
    public string Text { get; set; } = string.Empty;

    [Parameter]
    public int CursorPosition { get; set; }

    [Parameter]
    public string InputChars
    {
        get => _inputChars;
        set
        {
            if (!_isActive)
            {
                return;
            }
            _inputChars = value;
            CheckForLineCompletion(_inputChars);
        }
    }

    [Parameter]
    public bool IsLineCompleted { get; set; }

    [Parameter]
    public bool IsLessonCompleted { get; set; }

    [Parameter]
    public bool IsCourseFinished { get; set; }

    [Parameter]
    public bool IsStatsUpdating { get; set; }

    [Parameter]
    public EventCallback<(int lineId, string textInput)> OnLineFinished { get; set; }

    private bool _isActive;
    private string _inputChars = string.Empty;
    private MarkupString[] _textSpans = [];
    private MarkupString[] _typedSpans = [];

    protected override void OnInitialized()
    {
        if (string.IsNullOrEmpty(Text))
        {
            _textSpans = [];

        }
        else
        {
            SetupTextSpans();
        }
    }

    private string GetCharClass(int index)
    {
        if (!_isActive)
        {
            return "";
        }

        if (IsCourseFinished)
        {
            return "text-success";
        }

        // Only process the current character being typed
        if (index == InputChars.Length - 1)
        {
            if (index < Text.Length)
            {
                return InputChars[index] == Text[index] ? "text-success" : "text-danger bg-red-100";
            }
        }
        // For already typed characters, return their existing state
        else if (index < InputChars.Length)
        {
            return InputChars[index] == Text[index] ? "text-success" : "text-danger bg-red-100";
        }

        return string.Empty;
    }

    private void CheckForLineCompletion(string userInput)
    {
        if (userInput.Length <= Text.Length)
        {
            IsLineCompleted = false;
        }
        else
        {
            IsLineCompleted = true;
            _isActive = false;
            OnLineFinished.InvokeAsync((Id, InputChars));
        }
    }

    private void SetupTextSpans()
    {
        _textSpans = new MarkupString[Text.Length];
        for (var i = 0; i < Text.Length; i++)
        {
            var displayChar = Text[i] == ' ' ? "&nbsp;" : Text[i].ToString();
            _textSpans[i] = new MarkupString($"<span key='{i}' class='monospace-font whitespace-pre'>{displayChar}</span>");
        }
    }
}